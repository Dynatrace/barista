<h1>Table</h1>

<docs-source-example [example]="examples.default"></docs-source-example>

<p>
  Styleguide: <a href="***REMOVED*** Style Guide</a>
</p>

<h2>Description</h2>
<p>
  The DT Angular data table enhances the Material's cdk table (https://material.angular.io/cdk/table/overview) but it also limits it in this first implementation (we are removing unneeded things from the public API)
</p>
<p>As per the style guide: "The table component can be either a static or an interactive element. It can be used to drill down to a details page and there is also the possibility to add, remove, edit a table row or even expand a row for further information."</p>
<!-- <p>
  As per groundhog: "The Groundhog table appears in three versions:
</p>
    <ul>
      <li>Standard table table</li>
      <li>Responsive table table--responsive</li>
      <li>The expandable table"</li>
    </ul> -->
<p>
  This version of the core table component just addresses a static data table. No user interaction with it allowed. So just groundhog's standard and responsive tables (equivalent to classes .table .tableâ€“responsive).
</p>
<p>
  This version does not yet allow for any of the following capabilities that Dynatrace's data tables need
</p>
<ul>
  <li>two lines per row tables.</li>
  <li>on hover reaction of any type (ex: on hover tool tips for icons)</li>
  <li>Filtering</li>
  <li>Sorting</li>
  <li>Pagination</li>
  <li>Problem/Warning indicators</li>
  <li>Edit mode</li>
  <li>Add/Remove/Delete rows</li>
  <li>Move Up/Down</li>
  <li>Buttons or Charts as content</li>
</ul>
<p>All pending functionality will be progressively addressed by future versions</p>

  <h2>Imports</h2>
<p>You have to import the <code>DtTableModule</code> when you want to use the <code>dt-table</code>:</p>
<!-- @formatter:off -->
<pre><code snippet language="typescript">@NgModule({{"{"}}
  imports: [
    ...
    DtTableModule,
  ],
{{"}"}})
class MyModule {{"{}"}}
</code></pre>
<!-- @formatter:on -->

<h2>Table Usage</h2>
<p>
The cdk table stablishes a very different approach on how to define the table template. It does not use the native HTML table. So there is no td, tr, th involved.
Instead, you need to define all possible columns that the table may show (depending on the data available) and then define the table header and body by selecting from the column definitions, which subset of columns you will show.
</p>
<p>
Each column definition is created with dt-header-cell and dt-cell inside an <a href="https://angular.io/guide/structural-directives#ngcontainer">ng-container</a> structural directive with a dtColumDef attribute directive applied to it.
</p>
<pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">dtColumnDef</span>=<span class="hljs-string">"username"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt-header-cell</span> *<span class="hljs-attr">dtHeaderCellDef</span>&gt;</span> User name <span class="hljs-tag">&lt;/<span class="hljs-name">dt-header-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt-cell</span> *<span class="hljs-attr">dtCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> <span ngNonBindable>{{row.a}} </span><span class="hljs-tag">&lt;/<span class="hljs-name">dt-cell</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre>

<p>(dtCellDef not only exports the row data but also the same properties as *ngFor using the same <a href="https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855">micro-syntax</a>)</p>

<p>The table header is defined next with a dt-header-row component and a dtHeaderRowDef directive:</p>

<pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">dt-header-row</span> *<span class="hljs-attr">dtHeaderRowDef</span>=<span class="hljs-string">"['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dt-header-row</span>&gt;</span></code>
</pre>

<p>And finally the table row is defined with a dt-row component and a dtRowDef directive:</p>

<pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code">
<span class="hljs-tag">&lt;<span class="hljs-name">dt-row</span> *<span class="hljs-attr">dtRowDef</span>=<span class="hljs-string">"let row; columns: ['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dt-row</span>&gt;</span>
</code></pre>

<p>(note: The dtRowDef also exports row context, which can be used for event and property bindings on the row element)</p>
<p>See the source code of any of the examples in this page to see all the pieces in place</p>

<h3>Width proportion</h3>
<p>You can customize the column width proportion with <code>[dtColumnProportion]</code></p>

<docs-source-example [example]="examples.width"></docs-source-example>

<h3>Empty state</h3>
<p>You can customize the empty Title and Message when the table is empty using the following tags: <code>&lt;dt-table-empty-state&gt;</code>, <code>&lt;dt-table-empty-state-image&gt;</code>, <code>&lt;dt-table-empty-state-title&gt;</code>, <code>&lt;dt-table-empty-state-message&gt;</code></p>

<docs-source-example [example]="examples.empty"></docs-source-example>

<p>Also you can pass custom content enclosing it between <code>&lt;dt-table-empty-state&gt;</code></p>

<docs-source-example [example]="examples.emptyCustom"></docs-source-example>

<h3>Loading state</h3>
<p>You can mark the Table as loading using <code>[isLoading]</code> and pass the content to display with <code>&lt;dt-table-loading-state&gt;</code>></p>

<docs-source-example [example]="examples.loading"></docs-source-example>

<h3>Observable as DataSource</h3>
<p>You can pass an Observable to the <code>[dataSource]</code> property</p>

<docs-source-example [example]="examples.observable"></docs-source-example>

<h3>
  Component and attribute directives for the table:
</h3>
<table class="table">
  <thead>
    <tr>
      <td width="190px">Component/Attribute</td>
      <td>Type</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dtColumnDef</code></td>
      <td>Attribute</td>
      <td>Name for the column (to be used in the header and row definitions)</td>
    </tr>
    <tr>
      <td><code>dtColumnType</code></td>
      <td>Attribute</td>
      <td>Type for the column (to be used in the alignment and for future versions add pipes and masks), possibles types are left-alignment <code>['left', 'text', 'id'],</code> center-alignment <code>['center', 'icon', 'control'],</code> right-alignment <code>['right', 'number', 'date', 'ip']</code></td>
    </tr>
    <tr>
      <td><code>dtColumnProportion</code></td>
      <td>Attribute</td>
      <td>A number describing the width proportion for the column <code>[dtColumnProportion]=2</code> means that this column will be double width as the regular ones</td>
    </tr>
    <tr>
      <td><code>dt-header-cell</code></td>
      <td>Directive</td>
      <td>Adds the right classes (the generic dt-header-cell and the cell specific dt-column-css_friendly_column_name) and role (so the browser knows how to parse it. In this case it makes it act as a column header in a native html table)</td>
    </tr>
    <tr>
      <td><code>*dtHeaderCellDef</code></td>
      <td>Attribute</td>
      <td>Captures the template of a column's header cell (the title for the column in the header) and as well as cell-specific properties so that the table can render the header properly. </td>
    </tr>
    <tr>
      <td><code>dt-cell</code></td>
      <td>Directive</td>
      <td>Adds the right classes and role (so the browser knows how to parse it. In this case it makes it act as a grid cell in a native html table)</td>
    </tr>
    <tr>
      <td><code>*dtCellDef</code></td>
      <td>Attribute</td>
      <td>Exports the the row data and the same properties as an <a href="https://angular.io/api/common/NgForOf">*ngFor</a> so that you can define what the cell should show. It also captures the template of the column's data row cell</td>
    </tr>
    <tr>
      <td><code>dt-header-row</code></td>
      <td>Component</td>
      <td>Placeholder for the header row. It is a container that contains the cell outlet. Adds the right class and role</td>
    </tr>
    <tr>
      <td><code>*dtHeaderRowDef</code></td>
      <td>Attribute</td>
      <td>Defines the visible columns in the header out of all the defined ones by receiving a columnName[]</td>
    </tr>
    <tr>
      <td><code>dt-row</code></td>
      <td>Component</td>
      <td>Placeholder for the data rows. It is a container that contains the cell outlet. Adds the right class and role</td>
    </tr>
    </tbody>
    <tr>
      <td><code>*dtRowDef</code></td>
      <td>Attribute</td>
      <td>Defines the visible columns in each row by receiving a columnName[] and also exposes the same micro-syntax that the dt-cell but for event and property binding</td>
    </tr>
    <tr>
      <td><code>dt-table-empty-state</code></td>
      <td>Component</td>
      <td>Placeholder for the content displayed when the table is empty</td>
    </tr>
    <tr>
      <td><code>dt-table-empty-state-image</code></td>
      <td>Component</td>
      <td>Placeholder for the image or icon to use within the <code>&lt;dt-table-empty-table&gt;</code></td>
    </tr>
    <tr>
      <td><code>dt-table-empty-state-title</code></td>
      <td>Component</td>
      <td>Placeholder for the title to use within the <code>&lt;dt-table-empty-table&gt;</code></td>
    </tr>
    <tr>
      <td><code>dt-table-empty-state-message</code></td>
      <td>Component</td>
      <td>Placeholder for the message to use within the <code>&lt;dt-table-empty-table&gt;</code></td>
    </tr>
  </table>

<h2>Inputs & Outputs</h2>
<table class="table">
  <thead>
    <tr>
      <td width="160px">Name</td>
      <td width="160px">Direction</td>
      <td width="250px">Type</td>
      <td width="160px">Default</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dataSource</code></td>
      <td>input</td>
      <td><code>object[] | Observable | DataSource </code></td>
      <td><code>undefined</code></td>
      <td>Data to be shown in the table</td>
    </tr>
    <tr>
      <td><code>emptyTitle</code></td>
      <td>input</td>
      <td><code>string</code></td>
      <td><code>"No data"</code></td>
      <td>Title to be shown when the table is empty</td>
    </tr>
    <tr>
      <td><code>emptyMessage</code></td>
      <td>input</td>
      <td><code>string</code></td>
      <td><code>"Sorry, there's no data to display"</code></td>
      <td>Message to be shown when the table is empty</td>
    </tr>
    <tr>
      <td><code>isLoading</code></td>
      <td>input</td>
      <td><code>boolean</code></td>
      <td><code>false</code></td>
      <td>Whether the Table is loading or not</td>
    </tr>
  </tbody>
</table>
There are no outputs at this stage. The table is totally passive.

<p>The DataSource type is an abstract class with two methods: connect and disconnect. Connect has to return an Observable that the table subscribes to. Disconnect does cleanup. Usin this class to wrap the data provided for the table allows for maximum flexibility and will be the responsible of a future sort, and filter functionalities</p>


<h2>Programmatic access</h2>
<h3>Through the table object</h3>
<ul>
  <li><code>addColumnDef()</code></li>
  <li><code>removeColumnDef()</code></li>
  <li><code>addRowDef()</code></li>
  <li><code>removeRowDef()</code></li>
  <li><code>renderRows()</code></li>
  <li><code>setHeaderRowDef()</code></li>
</ul>
<h3>Through the header object</h3>
<ul>
  <li><code>getColumnsDiff()</code></li>
</ul>

<h2>Styling</h2>
<p>
    The styling will be set for the core component and cannot be changed by the developer using the component. The component should be them-able, though.
</p>
<p>
    The only things the developer can set are
</p>
<ul>
  <li>the type of table which changes not only the functionality available but also (behind the scenes) some of the styling.</li>
  <li>the responsiveness of the table</li>
</ul>

<p>
    type TableType = 'static' | 'dynamic'
    responsive: Boolean

    Ex:

    ...
</p>

<p>
    Both type and responsive are optional and have default values
</p>
<ul>
    <li>type -> static</li>
    <li>responsive -> true</li>
</ul>
<p>
  The table will always
</p>
<ul>
    <li>show a zebra pattern between alternating rows.</li>
    <li>align each data type (and its column header) in a specific way</li>
</ul>

<h2>Theming</h2>
<p>
  The table styling depends on the theme the component is in. You can set a theme on an area of the app by using the <code>dtTheme</code> directive.<br>
</p>

<p><strong>NOTE:</strong><br>Right now only setting the light or dark mode is available. Full theming functionality will be added in a later stage.</p>
