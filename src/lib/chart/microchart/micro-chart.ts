import {
  ChangeDetectionStrategy, ChangeDetectorRef, Component, NgZone, Optional, SkipSelf, ViewEncapsulation
} from '@angular/core';
import { DataPoint, IndividualSeriesOptions} from 'highcharts';
import {DtChartOptions, DtChartSeries, DtTheme, DtViewportResizer} from '@dynatrace/angular-components';
import {DtChart} from '../chart';
import {
  DEFAULT_CHART_MICROCHART_OPTIONS, DEFAULT_MAX_DATAPOINT_OPTIONS, DEFAULT_MIN_DATAPOINT_OPTIONS,
  DEFAULT_MINMAX_DATAPOINT_OPTIONS
} from './micro-chart-options';
import {merge} from 'lodash';

@Component({
  moduleId: module.id,
  selector: 'dt-micro-chart',
  styleUrls: ['../chart.scss'],
  templateUrl: '../chart.html',
  exportAs: 'dtMicroChart',
  // disabled ViewEncapsulation because some html is generated by highcharts
  // so it does not get the classes from angular
  // tslint:disable-next-line: use-view-encapsulation
  encapsulation: ViewEncapsulation.None,
  preserveWhitespaces: false,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DtMicroChart extends DtChart {
  protected _mergeOptions(options: DtChartOptions): void {
    super._mergeOptions(merge({}, DEFAULT_CHART_MICROCHART_OPTIONS, options));
  }

  protected _mergeSeries(series: DtChartSeries | undefined): void {
    this._transformSeries(series);
    super._mergeSeries(series);
  }

  constructor(@Optional() _viewportResizer: DtViewportResizer,
              @Optional() @SkipSelf() _theme: DtTheme,
              _changeDetectorRef: ChangeDetectorRef,
              _ngZone: NgZone) {
    super(_viewportResizer, _theme, _changeDetectorRef, _ngZone);
  }

  private _transformSeries(series: DtChartSeries | undefined): void {

    if (series === undefined) {
      return;
    }

    // Return if there is no data
    if (series.length === 0) {
      return;
    }

    series.forEach((currentSeries: IndividualSeriesOptions) => {
      const dataPoints = DtMicroChart._normalizedData(currentSeries.data);
      const values = dataPoints.map((point: DataPoint) => point.y) as number[];

      const minIndex = values.lastIndexOf(Math.min(...values));
      const maxIndex = values.lastIndexOf(Math.max(...values));

      merge(dataPoints[minIndex], DEFAULT_MINMAX_DATAPOINT_OPTIONS, DEFAULT_MIN_DATAPOINT_OPTIONS);
      merge(dataPoints[maxIndex], DEFAULT_MINMAX_DATAPOINT_OPTIONS, DEFAULT_MAX_DATAPOINT_OPTIONS);
    });
  }

  /**
   * Converts a series to {@link DataPoint[]}
   */
  private static _normalizedData(seriesData: Array<number | [number, number] | [string, number] | DataPoint> | undefined):
    DataPoint[] {
    if (!seriesData || seriesData.length === 0) {
      return [];
    }

    // Convert (number | [number, number] | [string, number]) to DataPoint
    // In case of another data structure, we simply ignore it.
    const firstDataValue = seriesData[0];

    if (typeof firstDataValue === 'number') { // Case 'number'
      return (seriesData as number[])
        .map((value: number, index: number) => ({x: index, y: value}));

    } else if (firstDataValue instanceof Array) { // Case '[any, number]'
      const numberArraySeries = seriesData as Array<[number, number]>;
      return numberArraySeries.map((value: [number, number]) => ({x: value[0], y: value[1]}));

    } else if ('y' in firstDataValue) { // Case 'DataPoint'
      return seriesData as DataPoint[];
    }

    return [];
  }

  protected _mergeAxis(axis: 'xAxis' | 'yAxis' | 'zAxis'): void {
    this._mergeAxisWithOptions(axis, { visible: false });
    super._mergeAxis(axis);
  }
}
